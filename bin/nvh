#!/usr/bin/env bash
# shellcheck disable=SC1117,SC2155

#
# Setup.
#

readonly VERSION="3.0.1-0"
readonly NVH_PREFIX=${NVH_PREFIX=/usr/local}
readonly STASH_DIR=$NVH_PREFIX/nvh/versions

NODE_MIRROR=${NVH_NODE_MIRROR=https://nodejs.org/dist}
NODE_MIRROR=${NODE_MIRROR%/}
readonly NODE_MIRROR

NODE_DOWNLOAD_MIRROR=${NVH_NODE_DOWNLOAD_MIRROR=https://nodejs.org/download}
NODE_DOWNLOAD_MIRROR=${NODE_DOWNLOAD_MIRROR%/}
readonly NODE_DOWNLOAD_MIRROR

# Modified by command options, but otherwise constant
QUIET="false"
PRESERVE_NPM="false"

g_ls_remote_max_matches=${NVH_MAX_REMOTE_MATCHES=20}

g_custom_mirror_url=${NODE_MIRROR}
g_custom_folder_name="node"

#
# update_settings_from_version <version>
# e.g. <nightly/latest> means using download mirror and custom_name is nightly
#

function update_settings_from_version() {
  if is_download_folder "$1" ; then
    g_custom_folder_name="$1"
    g_custom_mirror_url="${NODE_DOWNLOAD_MIRROR}/${g_custom_folder_name}"
  elif is_download_folder "$1" || is_download_version "$1"; then
    [[ "$1" =~ ^([^/]+)/(.*) ]]
    local remote_folder="${BASH_REMATCH[1]}"
    g_custom_folder_name="${remote_folder}"
    g_custom_mirror_url="${NODE_DOWNLOAD_MIRROR}/${g_custom_folder_name}"
  fi
}

#
# log <action> <msg>
#

function log() {
  printf "  \033[36m%10s\033[0m : \e[2m%s\e[22m\033[0m\n" "$1" "$2"
}

#
# abort <messages...>
# Exit with the given messge
#

function abort() {
  >&2 printf "\n  \033[31mError: $*\033[0m\n\n" && exit 1
}

#
# trace <messages...>
#

function trace() {
  >&2 printf "trace: $*\n"
}

#
# Version test patterns
#

function is_lts_codename() {
  # https://github.com/nodejs/Release/blob/master/CODENAMES.md
  # e.g. argon, Boron
  [[ "$1" =~ ^([Aa]rgon|[Bb]oron)|[Cc]arbon|[Dd]ubnium|[Ee]rbium|[Ff]ermium|[Gg]allium|[Hh]ydrogen|[Ii]ron$ ]]
}

function is_release_branch() {
  # e.g. 8.x, v9.x
  [[ "$1" =~ ^[v]{0,1}[0-9]+\.x$ ]]
}

function is_download_folder() {
  # exact match for name
  [[ "$1" =~ ^(chakracore-nightly|chakracore-rc|chakracore-release|next-nightly|nightly|rc|release|test|v8-canary)$ ]]
}

function is_download_version() {
  # e.g. nightly/latest
  [[ "$1" =~ ^[^/]+/ ]]
}

function is_numeric_version() {
  # e.g. 6, v7.1, 8.11.3
  [[ "$1" =~ ^[v]{0,1}[0-9]+(\.[0-9]+){0,2}$ ]]
}

#
# Functions used when showing versions installed
#

function enter_fullscreen() {
  # Set cursor to be invisible
  tput civis 2> /dev/null
  # Save screen contents
  tput smcup
  stty -echo
}

function leave_fullscreen() {
  # Set cursor to normal
  tput cnorm 2> /dev/null
  # Restore screen contentsq
  tput rmcup
  stty echo
}

function handle_sigint() {
  leave_fullscreen
  S="$?"
  kill 0
  exit $S
}

function handle_sigtstp() {
  leave_fullscreen
  kill -s SIGSTOP $$
}

#
# Output usage information.
#

function display_help() {
  cat <<-EOF

  Usage: nvh [options] [COMMAND] [args]

  Commands:

    nvh                             Display downloaded node versions and install selection
    nvh <version>                   Install node <version> (downloading if necessary)
    nvh run <version> [args ...]    Execute downloaded node <version> with [args ...]
    nvh which <version>             Output path for downloaded node <version>
    nvh rm <version ...>            Remove the given downloaded version(s)
    nvh prune                       Remove all downloaded versions except the active version
    nvh ls                          Output downloaded versions
    nvh ls-remote [version]         Output matching versions available for download
    nvh help                        Display help information
    nvh doctor                      Output diagnostics to help solve issues

  Options:

    -V, --version       Output version of n
    -h, --help          Display help information
    -q, --quiet         Disable download progress (for curl)
    -p, --preserve      Preserve npm and npx during install of node

  Aliases:

    ls: list
    ls-remote: lsr, list-remote
    rm: remove

  Versions:

    Numeric version numbers can be complete or incomplete, with an optional leading 'v'.
    Versions can also be specified by lts or latest, by release stream,
    or other downloadable releases by <remote-folder>/<version>

      4.9.1, 8, v6.1    Numeric versions
      lts               Latest Long Term Support official release
      latest            Latest official release
      boron, v7.x       Release streams
      nightly/latest, chakracore-release/10, rc/v9.4.0-rc.1

  Examples:

    nvh latest      Install the latest node release
    nvh lsr lts     Output latest lts version
    nvh -p lts      Install latest LTS version, preserving installed npm and npx
    nvh             Display downloaded node versions and install selection

  See also https://github.com/JohnRGee/nvh.git for further information.

EOF
}

function err_no_installed_print_help() {
  printf "\n  \033[31mNo downloaded versions yet, displaying help\033[0m\n"
  display_help
  exit 1
}

#
# Output version after selected.
#

function next_version_installed() {
  list_stash_versions | grep "${selected}" -A 1 | tail -n 1
}

#
# Output version before selected.
#

function prev_version_installed() {
  list_stash_versions | grep "${selected}" -B 1 | head -n 1
}

#
# Output n version.
#

function display_nvh_version() {
  echo $VERSION && exit 0
}

#
# Check for installed version, and populate $active
#

function check_current_version() {
  local node_path="$(command -v node)"
  if [[ -x "${node_path}" ]]; then
    local current=$(node --version)
    for dir in ${STASH_DIR}/*/ ; do
      local folder_name="${dir%/}"
      folder_name="${folder_name##*/}"
      if diff &> /dev/null \
        "${STASH_DIR}/${folder_name}/${current}/bin/node" \
        "${node_path}" ; then
        active="${folder_name}/${current}"
      fi
    done
  fi
}

#
# Display sorted versions directories paths.
#

function versions_paths() {
  # e.g. node/v8.11.3
  # sort string . number . number . number

  find "${STASH_DIR}" -maxdepth 2 -type d \
    | sed 's|'"${STASH_DIR}"'/||g' \
    | grep -E "/v[0-9]+\.[0-9]+\.[0-9]+" \
    | sed 's|/v|.|' \
    | sort -k 1,1 -k 2,2n -k 3,3n -k 4,4n -t . \
    | sed 's|\.|/v|'
}

#
# Display installed versions with <selected>
#

function display_versions_with_selected() {
  selected="$1"
  echo
  for folder_and_version in $(versions_paths); do
    if [[ "${folder_and_version}" = "${selected}" ]]; then
      printf "  \033[36mÎ¿\033[0m ${folder_and_version}\033[0m\n"
    else
      printf "    \e[2m${folder_and_version}\e[22m\n"
    fi
  done
  echo
  printf "Use up/down arrow keys to select a version, return key to install, q to quit"
}

#
# List stash versions.
#

function list_stash_versions() {
  for folder_and_version in $(versions_paths); do
    echo "${folder_and_version}"
  done
}

#
# Display current node --version and others installed.
#

function display_stash_versions() {
  enter_fullscreen
  check_current_version
  clear
  display_versions_with_selected "${active}"

  trap handle_sigint INT
  trap handle_sigtstp SIGTSTP

  ESCAPE_SEQ=$'\033'
  UP=$'A'
  DOWN=$'B'

  while true; do
    read -rsn 1 key
    case "$key" in
      $ESCAPE_SEQ)
        # Handle ESC sequences followed by other characters, i.e. arrow keys
        read -rsn 1 -t 1 tmp
        if  [[ "$tmp" == "[" ]]; then
          read -rsn 1 -t 1 arrow
          case "$arrow" in
            $UP)
              clear
              display_versions_with_selected "$(prev_version_installed)"
              ;;
            $DOWN)
              clear
              display_versions_with_selected "$(next_version_installed)"
              ;;
          esac
        fi
        ;;
      "k")
        clear
        display_versions_with_selected "$(prev_version_installed)"
        ;;
      "j")
        clear
        display_versions_with_selected "$(next_version_installed)"
        ;;
      "q")
        clear
        leave_fullscreen
        exit
        ;;
      "")
        # enter key returns empty string
        leave_fullscreen
        activate "${selected}"
        exit
        ;;
    esac
  done
}

#
# Move up a line and erase.
#

function erase_line() {
  printf "\033[1A\033[2K"
}

#
# Check the HEAD response of <url>.
#

function is_ok() {
  # Note: both curl and wget can follow redirects, as present on some mirrors (e.g. https://npm.taobao.org/mirrors/node).
  # The output is complicated with redirects, so keep it simple and use command status rather than parse output.
  # Reminder, using $GET because may have username/password etc added.
  if command -v curl &> /dev/null; then
    ${GET} --fail --head "$1" &> /dev/null || return 1
  else
    ${GET} --spider "$1" &> /dev/null || return 1
  fi
}

#
# Determine tarball url for <version>
#

function tarball_url() {
  local version=$1
  local uname="$(uname -a)"
  local arch=x86
  local os=

  # from nave(1)
  case "$uname" in
    Linux*) os=linux ;;
    Darwin*) os=darwin ;;
    SunOS*) os=sunos ;;
  esac

  case "$uname" in
    *x86_64*) arch=x64 ;;
    *armv6l*) arch=armv6l ;;
    *armv7l*) arch=armv7l ;;
    *arm64*) arch=arm64 ;;
    *aarch64*) arch=arm64 ;;
  esac

  if [[ "${arch}" = "armv6l" ]]; then
    local semver=${version//./ }
    local major=$(echo "${semver}" | grep -o -E '[0-9]+' | head -1 | sed -e 's/^0\+//')
    local minor=$(echo "${semver}" | awk '{print $2}' | grep -o -E '[0-9]+' | head -1 | sed -e 's/^0\+//')
    [[ $major -eq "" && $minor -lt 12 ]] && arch=arm-pi
  fi

  echo "${g_custom_mirror_url}/${version}/node-${version}-${os}-${arch}.tar.gz"
}

#
# Disable PaX mprotect for <binary>
#

function disable_pax_mprotect() {
  [[ -z "$1" ]] && abort "binary required"
  local binary=$1

  # try to disable mprotect via XATTR_PAX header
  local PAXCTL=$(PATH="/sbin:/usr/sbin:$PATH" which paxctl-ng 2>&1)
  local PAXCTL_ERROR=1
  if [[ -x "$PAXCTL" ]]; then
    $PAXCTL -l && $PAXCTL -m "$binary" >/dev/null 2>&1
    PAXCTL_ERROR="$?"
  fi

  # try to disable mprotect via PT_PAX header
  if [[ $PAXCTL_ERROR != 0 ]]; then
    PAXCTL=$(PATH="/sbin:/usr/sbin:$PATH" which paxctl 2>&1)
    if [[ -x "$PAXCTL" ]]; then
      $PAXCTL -Cm "$binary" >/dev/null 2>&1
    fi
  fi
}

#
# activate <path_from_prefix>
# e.g. activate node/8.11.3, activate nightly/11.0.0-nightly201807118174d0c8ca
#

function activate() {
  local path_from_prefix=$1
  local dir="${STASH_DIR}/${path_from_prefix}"
  # Remove old npm to avoid potential issues with simple overwrite.
  if [[ "${PRESERVE_NPM}" = "false" && -d "$dir/lib/node_modules/npm" ]]; then
    if [[ -d "$NVH_PREFIX/lib/node_modules/npm" ]]; then
      rm -rf "$NVH_PREFIX/lib/node_modules/npm"
    fi
  fi
  # Copy (lib before bin to avoid error messages on Darwin when cp over dangling link)
  for subdir in lib bin include share; do
    if [[ "${PRESERVE_NPM}" = "true" ]]; then
      mkdir -p "$NVH_PREFIX/$subdir"
      (cd "$dir/$subdir"; tar -cf - --exclude npm --exclude npx .) | (cd "$NVH_PREFIX/$subdir"; tar -xf -)
    elif [[ -L "$NVH_PREFIX/$subdir" ]]; then
      find "$dir/$subdir" -mindepth 1 -maxdepth 1 -exec cp -fR "{}" "$NVH_PREFIX/$subdir" \;
    else
      cp -fR "$dir/$subdir" "${NVH_PREFIX}"
    fi
  done
  disable_pax_mprotect "$NVH_PREFIX/bin/node"
  log "installed" "$(node --version)"
}

#
# Install <version>
#

function install() {
  local resolved_version=$(display_latest_resolved_version "$1")
  [[ -z "${resolved_version}" ]] && abort "did not find remote version for $1"
  update_settings_from_version "$1"

  local dir="${STASH_DIR}/${g_custom_folder_name}/${resolved_version}"

  if [[ -d "${dir}" ]]; then
    if [[ ! -e "${dir}/nvh.lock" ]] ; then
      activate "${g_custom_folder_name}/${resolved_version}"
      exit
    fi
  fi

  echo
  log "installing" "${g_custom_folder_name}/${resolved_version}"

  local url="$(tarball_url "${resolved_version}")"
  is_ok "${url}" || abort "download preflight failed for $resolved_version"

  log "mkdir" "${dir}"
  mkdir -p "${dir}"
  if [[ $? -ne 0 ]] ; then
    abort "sudo required"
  else
    touch "${dir}/nvh.lock"
  fi

  cd "${dir}"

  log "fetch" "${url}"
  $GET "${url}" | tar -zx --strip-components=1
  [[ "${QUIET}" = "false" ]] && erase_line
  rm -f "${dir}/nvh.lock"

  disable_pax_mprotect bin/node

  activate "${g_custom_folder_name}/${resolved_version}"
  echo
}

#
# Set curl to quiet (silent) mode.
#

function set_quiet_progress() {
  QUIET="true"
  command -v curl > /dev/null && GET="$GET -s"
}

#
# set number of remote matches
#

function set_show_all_remote_matches() {
  g_ls_remote_max_matches=32000
}

function set_show_single_remote_match() {
  g_ls_remote_max_matches=1
}

#
# Remove <version ...>
#

function remove_versions() {
  [[ -z "$1" ]] && abort "version(s) required"
  while [[ $# -ne 0 ]]; do
    local version="$(display_latest_resolved_version "$1")"
    if [[ -n "${version}" ]]; then
      update_settings_from_version "$1"
      local dir="${STASH_DIR}/${g_custom_folder_name}/${version}"
      if [[ -s "${dir}" ]]; then
        rm -rf "${dir}"
      else
        echo "$1 (${version}) not in downloads stash"
      fi
    else
      echo "invalid version $1"
    fi
    shift
  done
}

#
# Prune non-active versions
#

function prune_versions() {
  check_current_version
  for folder_and_version in $(versions_paths); do
    if [[ "${folder_and_version}" != "${active}" ]]; then
      echo "${folder_and_version}"
      rm -rf "${STASH_DIR}/${folder_and_version}"
      shift
    fi
  done
}

#
# Output bin path for <version>
#

function display_bin_path_for_version() {
  [[ -z "$1" ]] && abort "version required"
  local version="$(display_latest_resolved_version "$1")"
  [[ -z "${version}" ]] && abort "invalid version $1"

  update_settings_from_version "$1"
  local bin="${STASH_DIR}/${g_custom_folder_name}/${version}/bin/node"
  if [[ -f "${bin}" ]]; then
    printf "${bin}\n"
  else
    abort "$1 (${version}) not in downloads stash"
  fi
}

#
# Execute the given <version> of node with [args ...]
#

function execute_with_version() {
  [[ -z "$1" ]] && abort "version required"
  local version="$(display_latest_resolved_version "$1")"
  [[ -z "$version" ]] && abort "invalid version $1"

  update_settings_from_version "$1"
  local bin="${STASH_DIR}/${g_custom_folder_name}/${version}/bin/node"

  if [[ -f "${bin}" ]]; then
    shift # remove version from parameters
    exec "${bin}" "$@"
  else
    abort "$1 (${version}) not in downloads stash"
  fi
}

#
# Access remote, filter folders, sort by numeric version
# display_remote_version_folders <remote> <version_prefix?> <last_lines? = g_ls_remote_max_matches>
#

function display_remote_version_folders() {
  # Ensure trailing slash
  local remote_url=${1%/}/

  # Version could be empty, 1, v1.2, 1.2.3, 10.0.0-nightly201711117b3446e7bb
  local version_prefix=$2
  [[ -z "$version_prefix" ]] && version_prefix='[0-9]+'
  version_prefix="v${version_prefix#v}" # Ensure leading v
  # Make numeric version terminated, so 1.1 does not match 1.11 et al
  is_numeric_version "${version_prefix}" && version_prefix="${version_prefix}([.-].+){0,1}$"
  # Quote the dots so they are literal and not special in expression
  version_prefix=${version_prefix//\./\.}

  local last_lines="$3"
  [[ -z "${last_lines}" ]] && last_lines="${g_ls_remote_max_matches}"

  # filenames
  # dist:     v8.11.3/
  # nightly:  v10.0.0-nightly201711117b3446e7bb/
  # rc:       v10.1.0-rc.0/
  # test:     v10.0.0-test20180410edd9cc466a/

  # <a href="v9.3.1-nightly2018010930273d400c/">v9.3.1-nightly2018010930273d400c/</a>
  # --> "v9.3.1-nightly2018010930273d400c/"
  # --> v9.3.1-nightly2018010930273d400c
  # search for version_prefix
  # --> 9.3.1.-nightly2018010930273d400c
  # sort using number . number . number . text . number
  # --> v9.3.1-nightly2018010930273d400c
  $GET 2> /dev/null "${remote_url}" \
    | grep -E "</a>" \
    | grep -E -o 'href="[^"]+/"' \
    | grep -E -o 'v[0-9]+\.[0-9]+\.[0-9]+[^/]*' \
    | grep -E "^${version_prefix}" \
    | sed 's|v\(.*\)|\1|; s|-|.-|' \
    | sort -u -k 1,1n -k 2,2n -k 3,3n -k 4,4 -k 5,5n -t . \
    | sed 's|\.-|-|; s|.*|v&|' \
    | tail -n "${last_lines}"
}

#
# Access remote, filter files, sort by numeric version.
# display_remote_version_folders <remote> <last_lines? = g_ls_remote_max_matches>
#

function display_remote_files() {
  local remote_url=${1%/}/
  local last_lines="$2"
  [[ -z "${last_lines}" ]] && last_lines="${g_ls_remote_max_matches}"

  $GET 2> /dev/null "${remote_url}" \
    | grep -E "</a>" \
    | grep -E -o 'v[0-9]+\.[0-9]+\.[0-9]+' \
    | sort -u -k 1,1n -k 2,2n -k 3,3n -t . \
    | tail -n "${last_lines}"
}

#
# Display codename version.
#

function display_latest_codename_version() {
  local codename="$1"
  local folder_name=$($GET 2> /dev/null "${NODE_MIRROR}/" \
    | grep -E "</a>" \
    | grep -E -o "latest-$codename" \
    | sort \
    | tail -n1)
  [[ -z "${folder_name}" ]] && return 0

  display_remote_files "${NODE_MIRROR}/${folder_name}/" 1
}

#
# Display resolved version.
#

function display_latest_resolved_version() {
  local version=${1#node/}
  if [[ "${version}" =~ ^[v]{0,1}[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    # Just numbers, already resolved, no need to lookup first.
    version="v${version#v}"
    echo "${version}"
  else
    # Complicated recognising exact version, KISS and awlays lookup for now.
    set_show_single_remote_match
    display_remote_versions "$1"
  fi
}

#
# Display the latest lts release version.
#

function display_latest_lts_version() {
  # Find the alphabetical last codename
  local folder_name=$($GET 2> /dev/null "${NODE_MIRROR}/" \
    | grep -E "</a>" \
    | grep -E -o 'latest-[a-z]{2,}' \
    | sort \
    | tail -n1)

  display_remote_files "${NODE_MIRROR}/${folder_name}/" 1
}

#
# display_match_limit
#

function display_match_limit(){
  if [[ "${g_ls_remote_max_matches}" -gt 1 && "${g_ls_remote_max_matches}" -lt 32000 ]]; then
    echo "Listing remote... Displaying last ${g_ls_remote_max_matches} matches (use --all to see all)."
  fi
}


#
# display_remote_versions <version>
#

function display_remote_versions() {
  local version="$1"
  if [[ -z "${version}" ]]; then
    display_match_limit
    display_remote_version_folders "${NODE_MIRROR}/"
  elif [[ "${version}" = "lts" ]]; then
    display_latest_lts_version
  elif [[ "${version}" = "latest" ]]; then
    display_remote_version_folders "${NODE_MIRROR}/" "" 1
  elif is_download_folder "${version}"; then
    display_match_limit
    display_remote_version_folders "${NODE_DOWNLOAD_MIRROR}/${version}/"
  elif is_download_version "${version}"; then
    [[ "${version}" =~ ^([^/]+)/(.*) ]]
    local remote_folder="${BASH_REMATCH[1]}"
    version="${BASH_REMATCH[2]}"
    if [[ "${version}" = "latest" ]]; then
      display_remote_version_folders "${NODE_DOWNLOAD_MIRROR}/${remote_folder}/" "" 1
    else
      display_match_limit
      display_remote_version_folders "${NODE_DOWNLOAD_MIRROR}/${remote_folder}/" "${version}"
    fi
  elif is_lts_codename "${version}"; then
    # Only one version on nodejs/dist, so skip display_match_limit
    display_remote_files "${NODE_MIRROR}/latest-${version}/"
  elif is_release_branch "${version}"; then
    # Only one version on nodejs/dist, so skip display_match_limit
    version="v${version#v}"
    display_remote_files "${NODE_MIRROR}/latest-${version}/"
  else
    if [[ "${version}" =~ ^[v]{0,1}[0-9]+(\.[0-9]+){0,1}$ ]]; then
      # 8, v8.1: partial match so warn.
      display_match_limit
    fi
    display_remote_version_folders "${NODE_MIRROR}/" "${version}"
  fi

}

#
# Show useful diagnostics
#

function show_diagnostics() {
  echo "# Commands"
  echo "## bash"
  bash --version
  echo "## nvh"
  command -v nvh && nvh --version
  if command -v node &> /dev/null; then
    echo "## node"
    command -v node && node --version && echo "node engine: $(node -e 'console.log(process.jsEngine)')"
    echo "## npm"
    command -v npm && npm --version
  else
    echo "## node not found"
  fi

  echo
  echo "# nvh Setup"
  echo "node mirror: ${NODE_MIRROR}"
  echo "node downloads mirror: ${NODE_DOWNLOAD_MIRROR}"
  echo "install location: $NVH_PREFIX"
  [[ -n "${NVH_PREFIX}" ]] && echo "PATH: $PATH"
  echo "ls-remote max matches: ${g_ls_remote_max_matches}"
}

#######################################################################################################

#
# Ensure we have curl or wget support.
#

# ToDo: rename not-constants
CURL_PARAMS=( "-L"
              "-#")

WGET_PARAMS=( "-q"
              "-O-")

if [[ -n "$NVH_NODE_MIRROR_USER" ]];then
  if [[ -z "$NVH_NODE_MIRROR_PASSWORD" ]]; then
    abort "Must specify NVH_NODE_MIRROR_PASSWORD when supplying NVH_NODE_MIRROR_USER"
  fi
  CURL_PARAMS+=("-u $NVH_NODE_MIRROR_USER:$NVH_NODE_MIRROR_PASSWORD")
  WGET_PARAMS+=("--http-password=$NVH_NODE_MIRROR_PASSWORD"
                "--http-user=$NVH_NODE_MIRROR_USER")
elif [[ -n "$NVH_NODE_MIRROR_PASSWORD" ]]; then
  abort "Must specify NVH_NODE_MIRROR_USER when supplying NVH_NODE_MIRROR_PASSWORD"
fi

GET=

# wget support
command -v wget > /dev/null && GET="wget ${WGET_PARAMS[@]}"

command -v curl > /dev/null && GET="curl ${CURL_PARAMS[@]}"

[[ -z "$GET" ]] && abort "curl or wget required"

# ToDo: only create when needed?
VERSIONS_DIR=("${STASH_DIR}/node")
for dir in "${VERSIONS_DIR[@]}"; do
  [[ -d "${dir}" ]] || mkdir -p "${dir}"
done

#
# Handle arguments.
#

while [[ $# -ne 0 ]]; do
  case $1 in
    -V|--version) display_nvh_version ;;
    -h|--help|help) display_help; exit ;;
    -q|--quiet) set_quiet_progress ;;
    -p|--preserve) PRESERVE_NPM="true" ;;
    --all) set_show_all_remote_matches ;;
    which) shift; display_bin_path_for_version "$1"; exit ;;
    run) shift; execute_with_version "$@"; exit ;;
    rm|remove) shift; remove_versions "$@"; exit ;;
    prune) prune_versions; exit ;;
    lsr|ls-remote|list-remote)
      shift
      [[ "$1" = "--all" ]] && set_show_all_remote_matches && shift
      display_remote_versions "$1"
      exit
      ;;
    ls|list) versions_paths; exit ;;
    doctor) show_diagnostics; exit ;;
    *) install "$1"; exit ;;
  esac
  shift
done

# Test after parsing so can use options like --preserve with version selecton
[[ -z "$(versions_paths)" ]] && err_no_installed_print_help
display_stash_versions
